package org.example.tut.flowable;

import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.MessagePostProcessor;
import org.springframework.amqp.core.MessageProperties;
import org.springframework.amqp.rabbit.AsyncRabbitTemplate;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.stereotype.Component;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.util.concurrent.ListenableFutureCallback;

import java.util.concurrent.ExecutionException;

// This class is dedicated for flowable engine service tasks
@Component
public class RPCRabbitMqPublisher {
    @Autowired
    private AsyncRabbitTemplate asyncRabbitTemplate;
    @Autowired
    private DirectExchange directExchange;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public RPCRabbitMqPublisher(AsyncRabbitTemplate rabbitTemplate, DirectExchange directExchange) {
        this.asyncRabbitTemplate = rabbitTemplate;
        this.directExchange = directExchange;
    }

    // Send message , do some works, wait the return message
    public void sendAsynchronously(String processInstanceId,String message){
        Message msg = new Message(message,processInstanceId);
        System.out.println("Publisher is about to send message ...");
        System.out.println(msg.toString());
        System.out.println(asyncRabbitTemplate.toString());
        String ROUTING_KEY = "req.res";
        asyncRabbitTemplate.setReceiveTimeout(45000);
        ListenableFuture<String> listenableFuture =
                asyncRabbitTemplate.convertSendAndReceiveAsType(
                        directExchange.getName(),
                        ROUTING_KEY,
                        msg,
                        new ParameterizedTypeReference<String>() {
                        });
        // Do some other works
        try{
            System.out.println("Do some works while waiting!");
            Thread.sleep(3000);
            System.out.println("Finish working!");
        }
        catch (InterruptedException e){}
        // Wait for message to arrive
        try {
            String returnMessage = listenableFuture.get();
            System.out.println("Return message arrived");
            System.out.println(returnMessage.toString());
        } catch (InterruptedException | ExecutionException e) {
            // ...
            e.printStackTrace();
        }
        System.out.println("-----------------Finished message sending!----------------");
    }

    // Send message, add call back, do works, then execute call back response
    public void sendAsynchronouslyWithCallback(String processInstanceId,String message) {
        Message msg = new Message(message,processInstanceId);
        System.out.println("Publisher is about to send message ...");
        System.out.println(msg.toString());
        System.out.println(asyncRabbitTemplate.toString());
        String ROUTING_KEY = "req.res";
        asyncRabbitTemplate.setReceiveTimeout(45000);
        AsyncRabbitTemplate.RabbitConverterFuture<String> rabbitConverterFuture =
                asyncRabbitTemplate.convertSendAndReceiveAsType(
                        directExchange.getName(),
                        ROUTING_KEY,
                        msg,
                        new ParameterizedTypeReference<String>() {});

        rabbitConverterFuture.addCallback(new ListenableFutureCallback<String>() {
            @Override
            public void onFailure(Throwable ex) {
                // ...
                ex.printStackTrace();
            }

            @Override
            public void onSuccess(String returnMessage) {
                System.out.println("Receive return message" + returnMessage.toString());
                System.out.println("-----------------Finished message sending!----------------");
            }
        });

        // Do some other works
        try{
            System.out.println("Do some works while waiting!");
            Thread.sleep(3000);
            System.out.println("-----------------Finished works!----------------");
        }catch (InterruptedException e){}

    }

    // Send and forget, don't care about the response. Responses may be sent to other queue and handled by other workers
    public void sendAndForget(String processInstanceId,String message) {
        Message msg = new Message(message,processInstanceId);
        System.out.println("Publisher is about to send message ...");
        System.out.println(msg.toString());
        String ROUTING_KEY = "req.res";

        // We can control messageId generated by the framework
        String selfControlCorrelationId = "12345";
        MessagePostProcessor messagePostProcessor = oriMessage -> {
            MessageProperties messageProperties
                    = oriMessage.getMessageProperties();
            // Add metadata to direct the @RabbitListener that she should send response info to 'response-queue'
            messageProperties.setReplyTo("response-queue");
            // Change the default CorrelationId
            messageProperties.setCorrelationId(selfControlCorrelationId);
            return oriMessage;
        };

        rabbitTemplate.convertAndSend(directExchange.getName(),
                ROUTING_KEY,
                msg,
                messagePostProcessor);
    }
}
